package main

// PETSCII/ATASCII enhanced conversion tables and helpers.
// Tables are ported from SyncTERM's ciolib (utf8_codepages.c) unicode tables
// and mapped to Go runes. These provide byte->rune mappings for display and
// reverse rune->byte maps for keyboard input.

// Note: This is Phase 1: glyph mapping only. Control-sequence translation
// (cursor, color, clear) is handled in Phase 2 by dedicated processors.

// Special placeholder for unmapped characters
const replRune = '\ufffd'

// PETSCII Upper/Graphics (common default)
var petsciiUToUnicode = [256]rune{
    0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
    0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
    0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
    0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005a, 0x005b, 0x00a3, 0x005d, 0x2191, 0x2190,
    0x2500, 0x2660, 0x1fb72, 0x1fb78, 0x1fb77, 0x1fb76, 0x1fb7a, 0x1fb71,
    0x1fb74, 0x256e, 0x2570, 0x256f, 0x1fb7c, 0x2572, 0x2571, 0x1fb7d,
    0x1fb7e, 0x25cf, 0x1fb7b, 0x2665, 0x1fb70, 0x256d, 0x2573, 0x25cb,
    0x2663, 0x1fb75, 0x2666, 0x253c, 0x1fb8c, 0x2502, 0x03c0, 0x25e5,
    0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
    0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
    0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
    0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
    0x00a0, 0x258c, 0x2584, 0x2594, 0x2581, 0x258f, 0x2592, 0x2595,
    0x2590, 0x25e4, 0x258C, 0x251c, 0x2597, 0x2514, 0x2510, 0x2582,
    0x250c, 0x2534, 0x252c, 0x2524, 0x258e, 0x258d, 0x2588, 0x2580,
    0x2584, 0x2583, 0x1fb7f, 0x2596, 0x259d, 0x2518, 0x2598, 0x259a,
    0x2500, 0x2660, 0x1fb72, 0x1fb78, 0x1fb77, 0x1fb76, 0x1fb7a, 0x1fb71,
    0x1fb74, 0x256e, 0x2570, 0x256f, 0x1fb7c, 0x2572, 0x2571, 0x1fb7d,
    0x1fb7e, 0x25cf, 0x1fb7b, 0x2665, 0x1fb70, 0x256d, 0x2573, 0x25cb,
    0x2663, 0x1fb75, 0x2666, 0x253c, 0x1fb8c, 0x2502, 0x03c0, 0x25e5,
    0x00a0, 0x258c, 0x2584, 0x2594, 0x2581, 0x258f, 0x2592, 0x2595,
    0x2590, 0x25e4, 0x258C, 0x251c, 0x2597, 0x2514, 0x2510, 0x2582,
    0x250c, 0x2534, 0x252c, 0x2524, 0x258e, 0x258d, 0x2588, 0x2580,
    0x2584, 0x2583, 0x1fb7f, 0x2596, 0x259d, 0x2518, 0x2598, 0x03c0,
}

// PETSCII Lower/Uppercase
var petsciiLToUnicode = [256]rune{
    0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
    0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
    0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
    0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
    0x0040, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
    0x0078, 0x0079, 0x007a, 0x005b, 0x00a3, 0x005d, 0x2191, 0x2190,
    0x2500, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005a, 0x253c, 0x259f, 0x2502, 0x2599, 0x259b,
    0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
    0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
    0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
    0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd, 0xfffd,
    0x00a0, 0x258c, 0x2584, 0x2594, 0x2581, 0x258f, 0x2592, 0x2595,
    0x2590, 0x259c, 0x258C, 0x251c, 0x2597, 0x2514, 0x2510, 0x2582,
    0x250c, 0x2534, 0x252c, 0x2524, 0x258e, 0x258d, 0x2588, 0x2580,
    0x2584, 0x2583, 0x2713, 0x2596, 0x259d, 0x2518, 0x2598, 0x259a,
    0x2500, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005a, 0x253c, 0x259f, 0x2502, 0x2599, 0x259b,
    0x00a0, 0x258c, 0x2584, 0x2594, 0x2581, 0x258f, 0x2592, 0x2595,
    0x2590, 0x259c, 0x258C, 0x251c, 0x2597, 0x2514, 0x2510, 0x2582,
    0x250c, 0x2534, 0x252c, 0x2524, 0x258e, 0x258d, 0x2588, 0x2580,
    0x2584, 0x2583, 0x2713, 0x2596, 0x259d, 0x2518, 0x2598, 0x2599,
}

// ATASCII unicode map
var atasciiToUnicode = [256]rune{
    0x2665, 0x251c, 0x258C, 0x2518, 0x2524, 0x2510, 0x2571, 0x2572,
    0x25e2, 0x2597, 0x25e3, 0x259d, 0x2598, 0x2580, 0x2582, 0x2596,
    0x2663, 0x250c, 0x2500, 0x253c, 0x2022, 0x2584, 0x258e, 0x252c,
    0x2534, 0x258c, 0x2514, 0x001b, 0x2191, 0x2193, 0x2190, 0x2192,
    0x0020, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
    0x2666, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
    0x0078, 0x0079, 0x007a, 0x2660, 0x2502, 0x1f8b0, 0x0008, 0x0009,
    0x2665, 0x251c, 0x258a, 0x2518, 0x2524, 0x2510, 0x2571, 0x2572,
    0x25e4, 0x259b, 0x25e5, 0x2599, 0x259f, 0x2586, 0x2582, 0x259c,
    0x2663, 0x250c, 0x2500, 0x253c, 0x25d8, 0x2580, 0x258e, 0x252c,
    0x2534, 0x2590, 0x2514, 0x000d, 0x2191, 0x2193, 0x2190, 0x2192,
    0x2588, 0x0021, 0x0022, 0x0023, 0x0024, 0x0025, 0x0026, 0x0027,
    0x0028, 0x0029, 0x002a, 0x002b, 0x002c, 0x002d, 0x002e, 0x002f,
    0x0030, 0x0031, 0x0032, 0x0033, 0x0034, 0x0035, 0x0036, 0x0037,
    0x0038, 0x0039, 0x003a, 0x003b, 0x003c, 0x003d, 0x003e, 0x003f,
    0x0040, 0x0041, 0x0042, 0x0043, 0x0044, 0x0045, 0x0046, 0x0047,
    0x0048, 0x0049, 0x004a, 0x004b, 0x004c, 0x004d, 0x004e, 0x004f,
    0x0050, 0x0051, 0x0052, 0x0053, 0x0054, 0x0055, 0x0056, 0x0057,
    0x0058, 0x0059, 0x005a, 0x005b, 0x005c, 0x005d, 0x005e, 0x005f,
    0x2666, 0x0061, 0x0062, 0x0063, 0x0064, 0x0065, 0x0066, 0x0067,
    0x0068, 0x0069, 0x006a, 0x006b, 0x006c, 0x006d, 0x006e, 0x006f,
    0x0070, 0x0071, 0x0072, 0x0073, 0x0074, 0x0075, 0x0076, 0x0077,
    0x0078, 0x0079, 0x007a, 0x2660, 0x2502, 0x0007, 0x007f, 0x25b6,
}

var unicodeToPetsciiU map[rune]byte
var unicodeToPetsciiL map[rune]byte
var unicodeToAtascii map[rune]byte

func init() {
    // Build reverse maps
    unicodeToPetsciiU = make(map[rune]byte, 256)
    unicodeToPetsciiL = make(map[rune]byte, 256)
    unicodeToAtascii = make(map[rune]byte, 256)
    for i, r := range petsciiUToUnicode {
        if r != 0xfffd {
            unicodeToPetsciiU[r] = byte(i)
        }
    }
    for i, r := range petsciiLToUnicode {
        if r != 0xfffd {
            unicodeToPetsciiL[r] = byte(i)
        }
    }
    for i, r := range atasciiToUnicode {
        if r != 0xfffd {
            unicodeToAtascii[r] = byte(i)
        }
    }
}

// ConvertPETSCIIUToUTF8 converts PETSCII upper/graphics bytes to UTF-8 string
func ConvertPETSCIIUToUTF8(data []byte) string {
    runes := make([]rune, 0, len(data))
    inAnsi := false
    for i := 0; i < len(data); i++ {
        b := data[i]
        if b == 0x1B { // ESC begins ANSI sequence injected by translator
            inAnsi = true
            runes = append(runes, rune(b))
            continue
        }
        if inAnsi {
            runes = append(runes, rune(b))
            // End CSI on final byte 0x40-0x7E (simple heuristic)
            if b >= 0x40 && b <= 0x7E {
                inAnsi = false
            }
            continue
        }
        // Preserve ASCII control characters needed for terminal operations
        // BS (0x08), TAB (0x09), LF (0x0A), CR (0x0D)
        if b < 0x20 && (b == 0x08 || b == 0x09 || b == 0x0A || b == 0x0D) {
            runes = append(runes, rune(b))
            continue
        }
        // Also preserve space (0x20) which is used in DELETE sequence
        if b == 0x20 {
            runes = append(runes, ' ')
            continue
        }
        r := petsciiUToUnicode[b]
        if r == 0 {
            r = replRune
        }
        runes = append(runes, r)
    }
    return string(runes)
}

// ConvertPETSCIILToUTF8 converts PETSCII lower/uppercase bytes to UTF-8 string
func ConvertPETSCIILToUTF8(data []byte) string {
    runes := make([]rune, 0, len(data))
    inAnsi := false
    for i := 0; i < len(data); i++ {
        b := data[i]
        if b == 0x1B {
            inAnsi = true
            runes = append(runes, rune(b))
            continue
        }
        // NOTE: Do NOT treat 0x9B as CSI here - in PETSCII context,
        // 0x9B is a legitimate PETSCII byte (light gray), not ANSI CSI
        if inAnsi {
            runes = append(runes, rune(b))
            if b >= 0x40 && b <= 0x7E {
                inAnsi = false
            }
            continue
        }
        // Preserve ASCII control characters needed for terminal operations
        // BS (0x08), TAB (0x09), LF (0x0A), CR (0x0D)
        if b < 0x20 && (b == 0x08 || b == 0x09 || b == 0x0A || b == 0x0D) {
            runes = append(runes, rune(b))
            continue
        }
        // Also preserve space (0x20) which is used in DELETE sequence
        if b == 0x20 {
            runes = append(runes, ' ')
            continue
        }
        r := petsciiLToUnicode[b]
        if r == 0 {
            r = replRune
        }
        runes = append(runes, r)
    }
    return string(runes)
}

// ConvertATASCIIToUTF8 converts ATASCII bytes to UTF-8 string
func ConvertATASCIIToUTF8(data []byte) string {
    runes := make([]rune, 0, len(data))
    inAnsi := false
    for i := 0; i < len(data); i++ {
        b := data[i]
        if b == 0x1B {
            inAnsi = true
            runes = append(runes, rune(b))
            continue
        }
        if inAnsi {
            runes = append(runes, rune(b))
            if b >= 0x40 && b <= 0x7E {
                inAnsi = false
            }
            continue
        }
        r := atasciiToUnicode[b]
        if r == 0 {
            r = replRune
        }
        runes = append(runes, r)
    }
    return string(runes)
}

// ConvertUTF8ToPETSCIIU converts a UTF-8 string to PETSCII upper/graphics bytes
func ConvertUTF8ToPETSCIIU(s string) []byte {
    out := make([]byte, 0, len(s))
    for _, r := range s {
        if b, ok := unicodeToPetsciiU[r]; ok {
            out = append(out, b)
        } else if r < 0x80 {
            out = append(out, byte(r))
        } else {
            out = append(out, '?')
        }
    }
    return out
}

// ConvertUTF8ToPETSCIIL converts a UTF-8 string to PETSCII lower/uppercase bytes
func ConvertUTF8ToPETSCIIL(s string) []byte {
    out := make([]byte, 0, len(s))
    for _, r := range s {
        if b, ok := unicodeToPetsciiL[r]; ok {
            out = append(out, b)
        } else if r < 0x80 {
            out = append(out, byte(r))
        } else {
            out = append(out, '?')
        }
    }
    return out
}

// ConvertUTF8ToATASCII converts UTF-8 string to ATASCII bytes
func ConvertUTF8ToATASCII(s string) []byte {
    out := make([]byte, 0, len(s))
    for _, r := range s {
        // Normalize CR/LF to ATASCII EOL (0x9B)
        if r == '\r' || r == '\n' {
            out = append(out, 0x9B)
            continue
        }
        if b, ok := unicodeToAtascii[r]; ok {
            out = append(out, b)
        } else if r < 0x80 {
            out = append(out, byte(r))
        } else {
            out = append(out, '?')
        }
    }
    return out
}
